分布式的环境其实是个很恶劣的环境,只不过随着JAVA的流行与普及,Zookeeper的出现将这个恶劣环境给掩盖了. Java天然适应分布式环境, 但对于其它语言的开发者就没那么幸运了. 让我们回顾一下分布式的基本概念,以及回顾一下在分布式设计时会遇到的挑战.

```mind
	-分布式的基础知识
		-分布式系统
			-硬件独立
			-软件统一
		-如何设计分布式系统
			-将系统拆分为子系统
			-规划子系统的通讯
			-考虑通讯过程中的安全
			-考虑子系统的可扩展性
			-保证子系统的可靠性
		-一致性
			-以数据尾中心的一致性
				-严格一致性
				-持续一致性
				-顺序一致性
				-因果一致性
				-入口一致性
			-以客户为中心的一致性
				-单调读一致性
				-单调写一致性
				-读写一致性
				-写读一致性
		-容错性
			-容错要求
				-可用性
				-可靠性
				-安全性
				-可维护性
			-故障分类
				-暂时故障
				-间歇性故障
				-持久性故障
			-典型故障
				-崩溃
				-遗漏
				-定时故障
				-响应性故障
				-任意性故障
					-最严重的故障
					-产生恶意的错误结果
					-又称为拜占庭故障
		-cap理论,三者不可兼得:
			-一致性 Consistency
			-可用性 Availablity
			-分区容错性 Partition Tolerance
		-base理论,对cap的一致性和可用性的权衡总结:
			-基本可用：Basic Available
			-最终一致性：Eventually Consistent
	```
	

在分布式设计/编码中, 我们会遇到的一些挑战:
```mind
-分布式的挑战
	-异构性
		-网络
		-计算机硬件
		-操作系统
		-编程语言
		-由不同的开发者完成
	-缺乏全局时钟,不知道调用的先后顺序
	-开放型
		-允许由不同程序员扩展不同的功能
		-服务之间要相互协作
	-安全性
	-透明性
		-访问透明性
		-位置透明性
		-并发透明性
		-复制透明性
		-故障透明性
		-移动透明性
		-伸缩透明性
	-并发性
	-故障独立性
		-监测故障
		-掩盖故障
		-容错
		-故障恢复
		-冗余
	-可伸缩性
```
在Zookeeper, 无状态微服务概念出现之前,无数的前辈做了很多的尝试去解决分布式的问题, 迎接分布式的挑战. 但都不能改变它是个恶劣环境的事实.
例如微软曾提供的DCOM(COM+), java 的CORBA,  RMI, 还有基于web service的SOA等等. 当你需要一个前后端必须以有状态紧密结合方式进行交互时, 网络故障\网络延时,就会成为一个绕不开的心头之痛.
不管底层采用何种技术, 当你请求一次服务端却发生超时的时候,你怎么判断应该进行何种操作?进行重试操作?还是回退?早期的分布式都会被类似于这类的问题所困惑. 所以它是个很恶劣的软件运行环境.

所以后期才会提出无状态服务, 幂等性操作等概念.以protobuf为代表的网络协议发展,带动了RPC技术更是进一步解决了网络异构性的问题.zookeeper的出现更是被称之为分布式系统的基石.

直到今天,当我们随手可以用几行代码搭建一个分布式系统时, 仍不要忘记分布式有分布式自己的挑战,它仍是一个恶劣的环境. 才不会有指望ZK能解决一切问题.经常埋怨踩坑ZK的情况